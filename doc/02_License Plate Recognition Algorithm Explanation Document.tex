\documentclass{article}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}

\title{License Plate Recognition Algorithm Explanation}
\begin{document}
	\maketitle
	
	\section{Image Channel}
	In OpenCV, images can be represented in 1, 2, 3, or 4 channels:
	\begin{itemize}
		\item Channel 1 is a grayscale image;
		\item The 2-channel images are RGB555 and RGB565. The 2-channel diagram may be used in program processing, such as Fourier transform, where one channel is a real number and the other is an imaginary number, mainly for ease of programming. RGB555 is 16 bits, 2 bytes, 5+6+5. The first 5 bits of the first byte are R, the last 3 bits plus the second byte are G, and the last 5 bits of the second byte are B. It can be seen that the original image has been compressed
		\item 3-channel color image (RGB);
		\item 4 channels are RGBA, which is RGB plus an A channel, also known as alpha channel, representing transparency. PNG images are a typical type of 4-channel image. The alpha channel can be assigned values from 0 to 1 or from 0 to 255, indicating transparency to opacity
		CvType type constant combination rules
	\end{itemize}
	
	\subsection{CvType Type Constant Combination}
	\begin{itemize}
		\item Byte: number of bits, digits. There are 8 bytes, 16 bytes, 32 bytes, and 64 bytes; In Mat, the space occupied by each pixel is 8 bits, which is CV\_8
		\item U\|S\|F ï¼š
		\begin{itemize}
			\item U: unsigned int, unsigned integer
			\item S: signed int, signed integer
			\item F: float, single precision floating-point type, float type itself has a sign
			The terms signed and unsigned here refer to binary encoding of images. In the process of writing, I mostly use unsigned symbols, namely CV\_8U and CV\_16U, when there is calculation involved
			\item C [channels]: The number of channels in an image
			**For example, CV\_8UC3 is an 8-bit unsigned 3-channel (RGB color) image**
		\end{itemize}
	\end{itemize}
	
	\section{Grayscale Image}
	\begin{itemize}
		\item Grayscale conversion is the process of making the R, G, and B components of a color image equal.
		\item Each pixel in a grayscale image has only one sample color, with a value between black (0) and white (255).
	\end{itemize}
	
	\texttt{Imgproc.cvtColor(inMat, dst, Imgproc.COLOR\_BGR2GRAY);}
	
	\section{Image Filtering (Noise Reduction)}
	Image filtering suppresses the noise of the target image while preserving details. It can be used to blur or eliminate noise.
	\subsection{Gaussian Filtering}
	Gaussian blur convolves a kernel (e.g., 3x3 or 5x5) with the original image. It smooths images and suppresses noise.
	
	\texttt{Imgproc.GaussianBlur(inMat, dst, ksize, 0, 0, Core.BORDER\_DEFAULT);}
	
	\subsection{Median Filtering}
	Median filtering replaces the grayscale value of a pixel with the median grayscale value in its neighborhood, useful for removing salt and pepper noise.
	
	\texttt{Imgproc.MedianBlur(inMat, dst, ksize);}
	
	\subsection{Mean Filtering}
	Mean filtering can blur images and is less effective at removing noise while preserving details.
	
	\texttt{Imgproc.blur(inMat, dst, ksize, anchor, Core.BORDER\_DEFAULT);}
	
	\section{Affine Transformation}
	Common transformations such as scaling, rotation, and translation are types of affine transformations. Affine transformation involves transforming spatial coordinates and interpolating grayscale values.
	
	\subsection{Translation}
	Translation shifts spatial coordinates by specific amounts along the x and y axes.
	
	\begin{equation}
		dst = A \cdot inMat
	\end{equation}
	Where A is the affine matrix.
	
	\texttt{Imgproc.warpAffine(inMat, dst, trans\_mat, inMat.size());}
	
	\subsection{Scaling}
	Scaling is used to zoom in or out of an image, with options to lock or unlock the aspect ratio.
	
	\texttt{Imgproc.resize(inMat, dst, dst.size(), ratio, ratio, Imgproc.INTER\_CUBIC);}
	
	\subsection{Rotation}
	Rotation can be clockwise (positive angle) or counterclockwise (negative angle).
	
	\texttt{Imgproc.getRotationMatrix2D(center, angle, 1);}
	
	\section{Projection Transformation}
	Projection transformation projects the image onto a new plane, similar to a perspective shift.
	
	\texttt{Imgproc.getPerspectiveTransform(srcPoints, dstPoints);}
	
	\section{Edge Detection}
	\subsection{Sobel Operation}
	Sobel is a first-order gradient algorithm used for edge detection, applying derivative operations to obtain horizontal and vertical gradients.
	
	\texttt{Imgproc.Sobel(inMat, grad\_x, CvType.CV\_8U, 1, 0, SOBEL\_KERNEL);}
	
	\subsection{Scharr Operation}
	Scharr provides more edge details compared to Sobel.
	
	\texttt{Imgproc.Scharr(inMat, grad\_x, CvType.CV\_32F, 1, 0);}
	
	\section{Image Binarization}
	Binarization converts an image into black and white based on a threshold, useful for edge detection and contour extraction.
	
	\section{Contour Extraction}
	Contour extraction identifies the edges of objects in an image. It is used in license plate recognition to extract and process the license plate region.
	
\end{document}